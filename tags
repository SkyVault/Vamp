!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
$	src/body.nim	/^proc `$`* (o: Body): string=$/;"	o
*	src/maths.nim	/^proc `*`* (a, b: V2): V2= return Vec2(a.x * b.x, a.y * b.y)$/;"	o
*	src/maths.nim	/^proc `*`* (a: (float, float), b: float): V2= return Vec2(a[0] * b, a[1] * b)$/;"	o
*	src/maths.nim	/^proc `*`* (a: V2, b: (float, float)): V2= return Vec2(a.x * b[0], a.y * b[1])$/;"	o
*	src/maths.nim	/^proc `*`* (a: V2, b: float): V2= return Vec2(a.x * b, a.y * b)$/;"	o
*=	src/maths.nim	/^proc `*=`* (a, b: V2)= a.x *= b.x; a.y *= b.y$/;"	o
*=	src/maths.nim	/^proc `*=`* (a: V2, b: (float, float))= a.x *= b[0]; a.y *= b[1]$/;"	o
*=	src/maths.nim	/^proc `*=`* (a: V2, b: float)= a.x *= b; a.y *= b$/;"	o
+	src/maths.nim	/^proc `+`* (a, b: V2): V2= return Vec2(a.x + b.x, a.y + b.y)$/;"	o
+	src/maths.nim	/^proc `+`* (a: (float, float), b: float): V2= return Vec2(a[0] + b, a[1] + b)$/;"	o
+	src/maths.nim	/^proc `+`* (a: V2, b: (float, float)): V2= return Vec2(a.x + b[0], a.y + b[1])$/;"	o
+	src/maths.nim	/^proc `+`* (a: V2, b: float): V2= return Vec2(a.x + b, a.y + b)$/;"	o
+=	src/maths.nim	/^proc `+=`* (a, b: V2)= a.x += b.x; a.y += b.y$/;"	o
+=	src/maths.nim	/^proc `+=`* (a: V2, b: (float, float))= a.x += b[0]; a.y += b[1]$/;"	o
+=	src/maths.nim	/^proc `+=`* (a: V2, b: float)= a.x += b; a.y += b$/;"	o
-	src/maths.nim	/^proc `-`* (a, b: V2): V2= return Vec2(a.x - b.x, a.y - b.y)$/;"	o
-	src/maths.nim	/^proc `-`* (a: (float, float), b: float): V2= return Vec2(a[0] - b, a[1] - b)$/;"	o
-	src/maths.nim	/^proc `-`* (a: V2, b: (float, float)): V2= return Vec2(a.x - b[0], a.y - b[1])$/;"	o
-	src/maths.nim	/^proc `-`* (a: V2, b: float): V2= return Vec2(a.x - b, a.y - b)$/;"	o
-=	src/maths.nim	/^proc `-=`* (a, b: V2)= a.x -= b.x; a.y -= b.y$/;"	o
-=	src/maths.nim	/^proc `-=`* (a: V2, b: (float, float))= a.x -= b[0]; a.y -= b[1]$/;"	o
-=	src/maths.nim	/^proc `-=`* (a: V2, b: float)= a.x -= b; a.y -= b$/;"	o
/	src/maths.nim	/^proc `\/`* (a, b: V2): V2= return Vec2(a.x \/ b.x, a.y \/ b.y)$/;"	o
/	src/maths.nim	/^proc `\/`* (a: (float, float), b: float): V2= return Vec2(a[0] \/ b, a[1] \/ b)$/;"	o
/	src/maths.nim	/^proc `\/`* (a: V2, b: (float, float)): V2= return Vec2(a.x \/ b[0], a.y \/ b[1])$/;"	o
/	src/maths.nim	/^proc `\/`* (a: V2, b: float): V2= return Vec2(a.x \/ b, a.y \/ b)$/;"	o
/=	src/maths.nim	/^proc `\/=`* (a, b: V2)= a.x \/= b.x; a.y \/= b.y$/;"	o
/=	src/maths.nim	/^proc `\/=`* (a: V2, b: (float, float))= a.x \/= b[0]; a.y \/= b[1]$/;"	o
/=	src/maths.nim	/^proc `\/=`* (a: V2, b: float)= a.x \/= b; a.y \/= b$/;"	o
CurrentGameState	src/platform.nim	/^proc CurrentGameState* (): auto = current_gamestate$/;"	f
DialogBoxHandler	src/dialog.nim	/^template DialogBoxHandler* = dialogBox$/;"	t
EntityWorld	src/ecs.nim	/^template EntityWorld* (): auto = world$/;"	t
GameClock	src/platform.nim	/^template GameClock* (): auto = clock$/;"	t
GameState	src/platform.nim	/^  GameState* = enum$/;"	t
ImageObj	src/art.nim	/^  ImageObj = object of RootObj$/;"	t
IsButtonDown	src/input.nim	/^# proc IsButtonDown( )$/;"	f
IsGamepadConnected	src/input.nim	/^# proc IsGamepadConnected* (, which = 0): bool=$/;"	f
MainCamera	src/art.nim	/^template MainCamera* (): Camera= camera$/;"	t
Pause	src/platform.nim	/^proc Pause* ()=$/;"	f
Quit	src/platform.nim	/^proc Quit* ()=$/;"	f
R2D	src/platform.nim	/^template R2D* (): auto = renderer$/;"	t
Result	src/platform.nim	/^  Result* = enum$/;"	t
SceneState	src/scenery.nim	/^  SceneState* = enum$/;"	t
Scenery	src/scenery.nim	/^template Scenery* (): auto = sce$/;"	t
SetTiledObjects	src/systems/physics.nim	/^proc SetTiledObjects* (objs: seq[TiledObject])=$/;"	f
Vec2	src/maths.nim	/^proc Vec2* (x = 0.0, y = 0.0): V2=$/;"	f
WalkerPhysicsObject	src/systems/enemies.nim	/^proc WalkerPhysicsObject(self: Entity, obj: PhysicsObject)=$/;"	f
WalkerUpdate	src/systems/enemies.nim	/^proc WalkerUpdate(self: Entity)=$/;"	f
Win	src/platform.nim	/^template Win* (): auto = window$/;"	t
ZombieUpdate	src/systems/enemies.nim	/^proc ZombieUpdate(self: Entity)=$/;"	f
add	src/ecs.nim	/^proc add* [T](self: Entity, component: T): T {.discardable.} =$/;"	f
addImage	src/assets.nim	/^proc addImage* (i: Image, id: string)=$/;"	f
addJson	src/assets.nim	/^proc addJson* (j: JsonNode, id: string)=$/;"	f
alpha	src/art.nim	/^proc alpha* (obj: Image): int =$/;"	f
alpha=	src/art.nim	/^proc `alpha=`* (obj: Image, alpha: int) =$/;"	o
blend	src/art.nim	/^proc blend* (obj: Image): sdl.BlendMode =$/;"	f
blend=	src/art.nim	/^proc `blend=`* (obj: Image, mode: sdl.BlendMode) {.inline.} =$/;"	o
center	src/body.nim	/^proc center* (b: Body): V2= Vec2(b.x + b.width \/ 2, b.y + b.height \/ 2)$/;"	f
contains	src/body.nim	/^proc contains* (body, other: Body): bool =$/;"	f
contains	src/body.nim	/^proc contains* (body: Body, other: V2): bool =$/;"	f
createEntity	src/ecs.nim	/^proc createEntity* (world: World): auto {.discardable.}=$/;"	f
createSystem	src/ecs.nim	/^proc createSystem* ($/;"	f
default_destroy	src/ecs.nim	/^proc default_destroy      (s: System, e: Entity) = discard$/;"	f
default_load	src/ecs.nim	/^proc default_load         (s: System, e: Entity) = discard$/;"	f
default_preDraw	src/ecs.nim	/^proc default_preDraw      (s: System)            = discard$/;"	f
default_preUpdate	src/ecs.nim	/^proc default_preUpdate    (s: System)            = discard$/;"	f
default_render	src/ecs.nim	/^proc default_render       (s: System, e: Entity) = discard$/;"	f
default_update	src/ecs.nim	/^proc default_update       (s: System, e: Entity) = discard$/;"	f
distance	src/maths.nim	/^proc distance* (v1, v2: V2): float=$/;"	f
draw	src/art.nim	/^proc draw* (renderer: sdl.Renderer, obj: Image, reg: Region, x, y: float, rot = 0.0, flip = false, ox = -1, oy = -1): bool {.discardable.}=$/;"	f
draw	src/art.nim	/^proc draw* (renderer: sdl.Renderer, obj: Image, x, y: float, rot = 0.0, flip = false, ox = -1, oy = -1): bool {.discardable.}=$/;"	f
draw	src/dialog.nim	/^proc draw* =$/;"	f
draw	src/ecs.nim	/^proc draw* (world: World)=$/;"	f
draw	src/scenery.nim	/^proc draw* (sc: SceneManager)=$/;"	f
draw	src/systems/ai.nim	/^  draw=proc(sys: System, self: Entity)=$/;"	t
draw	src/systems/physics.nim	/^  draw = proc(sys: System, self: Entity)=$/;"	t
draw	src/systems/renderable.nim	/^  draw = proc(s: System, e: Entity)=$/;"	t
drawTiledMap	src/art.nim	/^proc drawTiledMap* (renderer: sdl.Renderer, map: TiledMap, texture: Image, ox, oy = 0.0)=$/;"	f
free	src/art.nim	/^proc free* (obj: Image) = sdl.destroyTexture(obj.texture)$/;"	f
get	src/ecs.nim	/^proc get* (self: Entity, T: typedesc): T =$/;"	f
getAllThatMatch	src/ecs.nim	/^proc getAllThatMatch* (matchlist: seq[string]): seq[Entity]=$/;"	f
getImage	src/assets.nim	/^proc getImage* (id: string): auto= images[id]$/;"	f
getJson	src/assets.nim	/^proc getJson* (id: string): auto= jsons[id]$/;"	f
getKeyInRange	src/input.nim	/^proc getKeyInRange(key: cint): int=$/;"	f
goto	src/scenery.nim	/^proc goto* (sc: SceneManager, scene: Scene): Scene {.discardable.}=$/;"	f
h	src/art.nim	/^proc h* (obj: Image): int {.inline.} = return obj.h$/;"	f
has	src/ecs.nim	/^proc has* (self: Entity, T: typedesc): bool=$/;"	f
has	src/ecs.nim	/^proc has* (self: Entity, t: string): bool=$/;"	f
height	src/body.nim	/^proc height* (b: Body): float= b.size.y$/;"	f
height=	src/body.nim	/^proc `height=`* (b: Body, v: float) = b.size.y = v$/;"	o
init	src/platform.nim	/^proc init* (size: (int, int), title: string): Result=$/;"	f
initInput	src/input.nim	/^proc initInput* ()=$/;"	f
inputHandleEvent	src/input.nim	/^proc inputHandleEvent* (ev: sdl.Event)=$/;"	f
inputUpdate	src/input.nim	/^proc inputUpdate* ()=$/;"	f
isKeyDown	src/input.nim	/^proc isKeyDown* (key: Key): bool =$/;"	f
isKeyPressed	src/input.nim	/^proc isKeyPressed* (key: Key): bool=$/;"	f
isKeyReleased	src/input.nim	/^proc isKeyReleased* (key: Key): bool=$/;"	f
isKeyUp	src/input.nim	/^proc isKeyUp* (key: Key): bool =$/;"	f
isMouseLeftDown	src/input.nim	/^proc isMouseLeftDown* (): bool=$/;"	f
isMouseLeftPressed	src/input.nim	/^proc isMouseLeftPressed* (): bool =$/;"	f
isMouseLeftReleased	src/input.nim	/^proc isMouseLeftReleased* (): bool =$/;"	f
isMouseLeftUp	src/input.nim	/^proc isMouseLeftUp* (): bool=$/;"	f
isMouseRightDown	src/input.nim	/^proc isMouseRightDown* (): bool=$/;"	f
isMouseRightPressed	src/input.nim	/^proc isMouseRightPressed* (): bool =$/;"	f
isMouseRightReleased	src/input.nim	/^proc isMouseRightReleased* (): bool =$/;"	f
isMouseRightUp	src/input.nim	/^proc isMouseRightUp* (): bool=$/;"	f
kill	src/ecs.nim	/^proc kill* (self: Entity)=$/;"	f
lineRect	src/art.nim	/^proc lineRect*(renderer: sdl.Renderer, x, y, w, h: float, rot=0.0)=$/;"	f
load	src/art.nim	/^proc load* (obj: Image, renderer: sdl.Renderer, file: string): bool {.discardable.} =$/;"	f
load	src/items.nim	/^  load = proc(sys: System, self: Entity)=$/;"	t
load	src/systems/ai.nim	/^  load=proc(sys: System, self: Entity)=$/;"	t
load	src/systems/enemies.nim	/^  load = proc(sys: System, self: Entity)=$/;"	t
load	src/systems/player.nim	/^  load = proc(sys: System, self: Entity)=$/;"	t
load	src/systems/renderable.nim	/^  load = proc(sys: System, self: Entity)=$/;"	t
loadImage	src/art.nim	/^proc loadImage* (renderer: Renderer, path: string): Image=$/;"	f
makeEntity	src/entity_assembler.nim	/^proc makeEntity* (which: string, x, y: float): auto {.discardable.}=$/;"	f
matches	src/ecs.nim	/^proc matches(s: System, e: Entity): bool=$/;"	f
mouseDeltaPos	src/input.nim	/^proc mouseDeltaPos* (): (float, float)=$/;"	f
mouseDeltaX	src/input.nim	/^proc mouseDeltaX* (): float=return input.mouse_x - input.last_mouse_x$/;"	f
mouseDeltaY	src/input.nim	/^proc mouseDeltaY* (): float=return input.mouse_y - input.last_mouse_y$/;"	f
mousePos	src/input.nim	/^proc mousePos* (): (float, float)=$/;"	f
mouseX	src/input.nim	/^proc mouseX* (): float= return input.mouse_x$/;"	f
mouseY	src/input.nim	/^proc mouseY* (): float= return input.mouse_y$/;"	f
newAi	src/systems/ai.nim	/^proc newAi* (update:proc(world: World, self: Entity) = updateDef): auto=$/;"	f
newBody	src/body.nim	/^proc newBody* (x, y, w, h: float): Body=$/;"	f
newEnemy	src/systems/enemies.nim	/^proc newEnemy* (enemyType: EnemyType): Enemy=$/;"	f
newImage	src/art.nim	/^proc newImage* (): Image = Image(texture: nil, w: 0, h: 0)$/;"	f
newKeyState	src/input.nim	/^proc newKeyState(state = 0, last = 0): KeyState=$/;"	f
newPhysicsBody	src/systems/physics.nim	/^proc newPhysicsBody* (vx = 0.0, vy = 0.0): PhysicsBody=$/;"	f
newPhysicsObject	src/systems/physics.nim	/^proc newPhysicsObject* (x, y, w, h: float, typeName: string): PhysicsObject=$/;"	f
newPlayer	src/systems/player.nim	/^proc newPlayer* (): Player=$/;"	f
newRectangleComponent	src/systems/renderable.nim	/^proc newRectangleComponent* (): RectangleComponent=$/;"	f
newRegion	src/art.nim	/^proc newRegion* (x, y, w, h: float): Region=$/;"	f
newScene	src/scenery.nim	/^proc newScene* (ev: proc(ev: SceneState)): Scene=$/;"	f
newSprite	src/systems/renderable.nim	/^proc newSprite* (img: Image, reg: Region): Sprite=$/;"	f
newSystem	src/ecs.nim	/^proc newSystem($/;"	f
newWorld	src/ecs.nim	/^proc newWorld* (): World=$/;"	f
oldLadyAi	src/systems/ai.nim	/^proc oldLadyAi* (world: World, self: Entity)=$/;"	f
placeMeeting	src/systems/physics.nim	/^proc placeMeeting* (point: V2): PhysicsObject=$/;"	f
pop	src/scenery.nim	/^proc pop* (sc: SceneManager): Scene {.discardable.}=$/;"	f
preDraw	src/systems/physics.nim	/^  preDraw = proc(s: System)=$/;"	t
preUpdate	src/systems/physics.nim	/^  preUpdate = proc(sys: System)=$/;"	t
pullControllerInfo	src/input.nim	/^proc pullControllerInfo(input: InputManager)=$/;"	f
push	src/scenery.nim	/^proc push* (sc: SceneManager, scene: Scene): Scene {.discardable.}=$/;"	f
readJsonAnimation	src/assets.nim	/^proc readJsonAnimation* (path: string)=$/;"	f
rect	src/art.nim	/^proc rect*(renderer: sdl.Renderer, x, y, w, h: float, rot=0.0)=$/;"	f
sdlRect	src/art.nim	/^proc sdlRect(r: Region): sdl.Rect=$/;"	f
setColor	src/art.nim	/^proc setColor* [T](renderer: sdl.Renderer, c: (T, T,T,T))=$/;"	f
showDialog	src/dialog.nim	/^proc showDialog* (node: JsonNode, point: V2)=$/;"	f
solidsCollisionCallback	src/systems/enemies.nim	/^    self.get(PhysicsBody).solidsCollisionCallback = proc(o: PhysicsObject)=$/;"	t
solidsCollisionCallback	src/systems/player.nim	/^    phys.solidsCollisionCallback = proc(o: PhysicsObject)=$/;"	t
update	src/dialog.nim	/^proc update* =$/;"	f
update	src/ecs.nim	/^proc update* (world: World)=$/;"	f
update	src/items.nim	/^  update = proc(sys: System, self: Entity)=$/;"	t
update	src/platform.nim	/^proc update* ()=$/;"	f
update	src/scenery.nim	/^proc update* (sc: SceneManager)=$/;"	f
update	src/systems/ai.nim	/^  update=proc(sys: System, self: Entity)=$/;"	t
update	src/systems/enemies.nim	/^  update = proc(sys: System, self: Entity)=$/;"	t
update	src/systems/physics.nim	/^  update = proc(sys: System, self: Entity)=$/;"	t
update	src/systems/player.nim	/^  update = proc(s: System, self: Entity)=$/;"	t
updateDef	src/systems/ai.nim	/^proc updateDef(world: World, self: Entity)= discard$/;"	f
w	src/art.nim	/^proc w* (obj: Image): int {.inline.} = return obj.w$/;"	f
width	src/body.nim	/^proc width* (b: Body): float= b.size.x$/;"	f
width=	src/body.nim	/^proc `width=`* (b: Body, v: float) = b.size.x = v$/;"	o
windowSize	src/platform.nim	/^proc windowSize* (): (int, int) =$/;"	f
windowSize=	src/platform.nim	/^proc `windowSize=`* (size: (int, int))=$/;"	o
x	src/body.nim	/^proc x* (b: Body): float= b.position.x$/;"	f
x=	src/body.nim	/^proc `x=`* (b: Body, v: float) = b.position.x = v$/;"	o
y	src/body.nim	/^proc y* (b: Body): float= b.position.y$/;"	f
y=	src/body.nim	/^proc `y=`* (b: Body, v: float) = b.position.y = v$/;"	o
